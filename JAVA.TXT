
환경변수 설정하기
JAVA_HOME
C:\Program Files\Java\jdk-20
C:\Program Files\Java\jdk-20\bin
    - 실행 파일이 있는 폴더

    java.exe : class 파일 실행
    javac.exe : java -> class 컴파일
    javadoc.exe : java api 문서를 생성

- 환경 변수 등록 목적 : 어떤 경로라도 항상 접근 가능 설정

3. 인텔리제이 

확장자 java -> 컴파일(javac 파일명.java) -> 확장자 class -> java 클래스 파일;

Write Once, Run EveryWhere

java -> .class (JVM 인식하는 중간언어) -> JVM(Java Virtual Machine - 자바 가상머신) - 플랫폼에 맞는 기계어로 컴파일

패키지 -> 폴더 : 비슷한 성격의 소스를 묶어 두기 위한 용도

패키지.서브패키지

변수와 자료형
1. 컴퓨터는 데이터를 어떻게 표현할까?
- 반도체 : 신호 O, 없고 X
            1,      0
        -> 2진수

            비트 : 1,0으로 표현하는 최소 단위
            바이트 : 1bit * 8 -> 1byte

            양수, 0, 음수

            8비트 -> 1비트 부호 비트(0 - 양수, 1 - 음수)
                    7비트 : 숫자

                    -2^7 ~ 2^7 - 1
                    (-126~125)


2. 10진수와 2진수
1100100 - 2진수
-> 10진수 : 100

3. 부호있는 수를 표현하는 방법



1. 변수란?
    - 변하는 수
    - 공간의 이름
    - 공간 : 메모리
    - 자료형 : 메모리의 크기

    메모리, 이름, 자료형

2. 변수 선언하고 값 대입하기
    자료형 변수명;
    
    대입 -> 자료형 변수명 = 값;

    참고) int - 정수형 자료형 (4byte)
    
    
3. 변수 초기화하기
    변수에 최초로 값을 대입(저장) 하는 것

    자료형 변수명 = 값; -> 선언과 동시에 초기화

4. 변수 이름 정하기
    1) 알파벳, 숫자, 특수문자($,#,...)
    2) 숫자는 맨 앞에 올 수 없음
    3) 예약어는 사용 불가(return, throw, if ...)
    4) 유의미한 단어로 변수명 구성

        int 1st; X
        int _$dollor O
        int noOfStudent O
        int throw X

        no Of Student - 카멜표기법
        no_Of_Student


    참고)
        주석 - 설명, 컴파일러가 해석 X, 제거
            // - 한줄 주석
            /**/ - 여러줄 주석

        2) 프로그램 실행 배제 - 해석 X -> 실행 X

변수가 저장되는 공간의 특성, 자료형
1. 변수와 메모리

자료형
- 기본 자료형
    - 숫자를 저장하는 자료형

    정수형 

    문자형 

    실수형 

    논리형 

- 참조 자료형
    - 다른 데이터의 주소를 참조하는 자료형

2. 기본 자료형의 종류

1) 정수 자료형
    byte  : 1바이트(8비트) -2^7 ~ 2^7 - 1 (-126~125)
    short : 2바이트(16비트) -2^15 ~ 2^15 - 1
    int   : 4바이트(32비트) -2^31 ~ 2^31 - 1
    long  : 8바이트(64비트) -2^63 ~ 2^63 - 1

2) 문자 자료형
    char : 2바이트

    참고) 숫자 변수에 대입 숫자 그대로 대입
        문자를 변수에 대입할 경우 '문자'

        숫자 - 문자 : 아스키코드(1byte)
                      /양의 정수
                      unsigned : 양의 정수
                      0~255

                      - 영문, 특수문자
        숫자 - 한글 : 유니코드(2byte, 3byte)

3) 실수 자료형
    - 소수점을 가지고 있는 숫자
    float : 4byte
            - 숫자 끝에 F(f)를 추가해야 인식

    double : 8byte

4) 논리 자료형
    - 참, 거짓 (true, false)
    boolean


기본 자료형 - 숫자 저장하는 자료형
    정수형
        1byte - byte
        2byte - short
        4byte - int
        8byte - long

    문자형(2,3byte)
        - 양의 정수(unsigned)
        2bytes - char

    실수형
        4byte - float
            - F(f)추가
        8byte - double

    논리형
        1byte - boolean

상수와 리터럴
1. 상수 선언하기
    - 상수 : 변하지 않는 수(constant)
    - final 예약어 변수명 앞에 추가
        - final : 변경 불가
    - 이름 명명 관례
        : 대문자
        : 단어 단어 사이는 _로 연결

2. 리터럴(literal)

    - 리터럴 상수
    - 재료가 되는 수 (문자, 숫자, 논리값)
    - 같은 재료 -> 하나만 생성(상수)

    - 정수 -> int로 인식 -> 자료형이 다른 경우 자료형 변경
    - long num = 10000000000000; -> int : 허용 가능 범위 X -> 오류 발생
    - L(l) 추가 : 처음부터 long으로 인식

    - 가장 효율적인 정수형 자료형 - int(4byte)
    - 가장 효율적인 실수형 자료형 - double(8byte)
        float num = 1000.1234; --> double float num = 1000.1234;(8) -> float(4)
            -F(f) 추가 : 처음부터 float로 인식
형변환
- 자료형간 변환
- byte -> int
- int -> byte

1. 묵시적 형변환
    - 자동 형변환
    - 작은 자료형 -> 큰 자료형
    - 정수(덜 정밀한 숫자) -> 실수(더 정밀한 숫자)
    - 연산 중 자동 형변환 : 연산은 같은 자료형만 가능 -> 연산을 위해서 자동 형변환

    정수 : 100
    실수 : 100.123

    0~1

    byte(1) -> short(2) -> int(4) -> long(8) -> float(4) -> double(8)
            -> char(2)


2. 명시적 형변환
    - 데이터의 유실이 발생할 가능성이 있는 경우 - 자동 형변환 X 
    - 명시적으로 형변환 의사 표현

    큰 자료형 -> 작은 자료형
    long -> int

    실수 -> 정수
    double -> long
    double -> int

    100.1234 -> 100

        (자료형)변수 


연산자
- 항과 연산자

    단항 연산
    이항 연산
    삼항 연산


- 항 : 연산에 필요한 값

- 연산자 : 연산에 필요한 기호

1. 대입 연산자
    - =
    - int num = 10; : 10이라는 값을 num 변수에 저장
    - int result = 10 + 30 * 2; : 마지막에 연산 결과가 대입 > 연산의 우선순위가 가장 낮은 연산자

2. 부호 연산자
    +, -

    - : 부호 반전
        양수 -> 음수
        음수 -> 양수

3. 산술 연산자
    +, -, *, /, % (나머지)

    - % : 균등 배분에 활용

    - 산술 연산자의 우선순위
        10 + 2 * 3 = 16
        (10 + 2) * 3 = 36

    *, /, % > +, -

    참고)
    () : 우선순위 강제 적용

4. 증가감소 연산자
    1씩 증가
        ++
    
        num++ // num = num + 1;
        ++num // num = num + 1;
        
    1씩 감소
        --

        num-- // num = num - 1;
  
5. 관계(비교) 연산자
6. 논리 연산자
- 단락회로 평가







9. 대입 연산자(=) < ...   논리연산자 < 비교연산자 < ... 단항연산자 < ... < ... (...)

연산자
    1) 대입 연산자
    2) 산술 연산자
    3) 부호 연산자
        - : 부호 반전
    4) 증가 감소 연산자
        ++
        num++
        ++num

        num2 = num++; 1) 대입 2) 연산
        num2 = ++num; 1) 연산 2) 대입
        --
    5) 비교 연산자
        연산 결과 - 논리값 : 조건문, 반복문

    6) 논리 연산자
        AND : &&
        OR : ||
        NOT : !
    
        AND, OR -> 단락회로평가

    7) 복합 대입 연산자
        대입 + 다른 연산자
        num += 2 -> num = 2;

    8) 삼항조건 연산자
        조건식 ? 참 : 거짓
        - 간단한 조건문을 대체
    
    9)  

        = < 논리 < 비교 <(...)


조건문 - 참, 거짓을 판별하는 식이 포함
        ( 조건식 - 비교, 논리 연산자 많이 사용 )

if (조건식) {
    // 조건식이 참일때 실행되는 코드;
}
if (조건식) {
    //조건식이 참일때 실행되는 코드;
}
else {
    //조건식이 참이 아닐때 실행되는 코드;
}

if (조건식1) {
    // 조건식1이 참일때 실행되는 코드;
} else if (조건식2) {
    // 조건식1 거짓 + 조건식2 참 -> 실행되는 코드;
} else if (조건식3) {
    // 조건식1,2 거짓 + 조건식3 참 -> 실행되는 코드;
}
...
else {
    // 모든 조건이 거짓일때 실행되는 코드;
}


선택문
    - 조건문에서 == 비교 연산은 구조적으로 간단하게 만드는 선택문
    - 키워드 = 값 : 실행 시점 -> break 만나기 전까지

    Switch ~ case

    switch(키워드){
        case 값1 :
            // 값1이 키워드와 동일 -> 수행되는 코드
            break;
        case 값2 :
            // 값2가 키워드와 동일 -> 수행되는 코드
            break;

        ...
        default :
            키워드가 모든 값에 매칭 X -> 수행되는 코드
    }

    - case에 사용되는 값 : 정수만 가능
        -> 문자열은 사용 가능 (JDK7)

반복문
    while(조건식) {
        // 조건식이 참일때 수행되는 코드
    }

    조건식 : 반복을 유지하는 조건, 반복을 중단 시킬 수 있는 조건

    do {
        // 조건식이 참일때 반복되는 코드
        // 조건식이 거짓이더라도 한번은 수행

    } while(조건식);


    횟수(순서)가 정해진 반복을 하려면
    1)초기값, 2)조건식, 3)증감식 필수요소

    - 횟수가 정해진 반복문 특화된 구문
    for(초기화식; 조건식; 증감식) {
        // 조건식이 참일때 수행되는 코드;
    }

    순서 : index (0부터 시작하는 순서 ...)

    변수명 관례
        i : 변수명
            - 중첩 for문 변수명 j, k, l, m, ...


    반복중단
        break;

    반복 건너뛰기
        - continue : 현재 반복 중단, 다음 반복을 시작

    중첩 반복문
        - 반복문 안에 반복문
            while + while, do~while, for
            do~while + while, do~while, for
            for + for, while, do~while

연습문제

자바스크립트 - 일주일 2번 : 자바스크립트 기초 + 심화
                          리액트, 노드



배열
1. 배열이란?

- 같은 자료형(공간의 크기가 동일)
- 물리적인 나열 구조(순차 자료 구조)
    -> 공간의 위치 계산이 쉽다
    -> [] : 인덱스 연산자, 0, 1, 2, 3, ... : 공간의 위치 연산


- 자료를 순차적으로 관리하는 구조

2. 배열 선언과 초기화
    ★자료형[]★ 배열명 = new 자료형[공간의 갯수];
    자료형 배열명[] = new 자료형[공간의 갯수];

    

3. 배열 사용하기
    - 인덱스 연산자
        [] : 배열 공간의 위치를 계산해 주는 연산자
            
        참고) 
            인덱스 : 0부터 시작하는 순서

    - 선언과 동시에 초기화
    자료형[] 배열명 = new 자료형[] { 값1, 값2, 값3 ... };
    자료형[] 배열명 = {값1, 값2, 값3 ...};
참고)
    기본 자료형 : 초기값
        정수형 자료형(byte, short, int ,long) -> 0
        실수형 자료형(float, double) -> 0.0
        논리형 자료형(boolean) -> false

    참조 자료형
        예) String - 초기값 null

4. 전체 배열 길이와 유효한 값
    모든 배열
        length : 공간의 갯수
        

5. 향상된 for 문과 배열

    for (요소 : 배열(컬렉션)) {
        
    }

    참고)
        java.util 패키지
            Arrays : 배열의 편의 기능
                .toString(...) : 1차원 배열
                .deep toString(...) : 다차원 배열

6. 다차원 배열
    1 차원[] : 직선
    2 차원[][] : 평면
    3 차원[][][] : 입체

    자료형[][] 배열명 = new 자료형[행][열];

    선언과 동시에 초기화
    자료형[][] 배열명 = new 자료형[][] {{값, 값, 값}, {값, 값, 값} ...}

    자료형[][] 배열명 = {{값, 값, 값}, {값, 값, 값} ...}

    ------------------------------------------------------------------------------------------------------------------------------------------------

    객체지향 프로그래밍1

    1. 객체 지향 프로그래밍과 클래스
    1) 객체와 객체 지향 프로그래밍

    - 객체?
        Object : 사물, 대상

        프로그래밍 언어
            객체
                속성, 상태 : 변수
                행위 : 함수

        자동차 : 객체
            - 엔진, 연료, 속도계, 연료량...(속성)
            - 움직인다.(행위)

        운전자 : 객체
            - 자동차 조작 행위

        객체간 협동(상호작용) / 의존
    
    2) 생활 속에서 객체 찾아보기

    2. 클래스 살펴보기
    - 객체를 만들기 위한 설계도

    1) 클래스를 정의하는 문법
    class 클래스명 {
        변수 정의 : 멤버 변수 정의
        함수 정의 : 멤버 메서드 정의
    }

    new 클래스명();

    마침표(.) : 멤버 변수, 멤버 메서드

    변수명.메서드명(); : 메서드 실행

    2) 클래스 이름을 짓는 규칙
        모든 단어의 첫 글자가 대문자
        예) Order + info -> OrderInfo

    3) 클래스의 속성을 구현하는 멤버변수

    3. 클래스와 인스턴스
        - 인스턴스(instance - 실체, 실제로 존재한다.) : 객체
        - 힙메모리

    4. 참조 자료형
        클래스 형 자료형 : 객체의 주소값만 가지고 참고해서 접근
            -> 참조 자료형
            -> 전부 동일한 크기

    메서드
    1. 함수란?
        - 기능을 어떻게 수행할지 정의한 코드

    2. 함수의 입력과 반환
        접근제어자 반환자료형 함수명(매개변수, ....) {
            // 수행할 코드 ...

            return 반환값;
        }



    3. 함수 정의하기
        1) 함수이름
        2) 매개변수
        3)return 예약어와 반환형
    4. 함수 호출하고 값 반환하기
    5. 매개변수 살펴보기
    6. 함수 호출과 스택 메모리
        - 함수가 실행될때 필요한 메모리 -> 스텍 영역에서 할당

        - 함수에서 정의된 변수 : 실행될때만 스택에서 공간 할당
            - 지역 변수


        참고)
            스택(Stack) 구조
                - 가장 먼저 투입된 자료 -> 가장 나중에 꺼낼 수 있는 구조
                - 가장 나중에 투입된 자료 -> 가장 처음에 꺼낼 수 있는 구조

            큐(Queue) 구조
                - 가장 먼저 투입된 자료 -> 가장 먼저 꺼낼 수 있다.
                - 가장 마지막에 투입된 자료 -> 가장 마지막에 꺼낼 수 있는 구조

                - 선착순

        main() 메서드 : 모든 프로그램의 시작 메서드

    7. 함수의 장점
    8. 클래스 기능을 구현하는 메서드



생성자
- 클래스명과 동일한 명칭의 함수
- 객체를 생성해주는 역할

데이터 영역 메모리(코드 & 상수 영역 메모리)

클래스 로더 -> 클래스 파일 -> 데이터 영역 로드

1. 디폴트 생성자(기본 생성자)
    - 클래스에 생성자 메서드가 정의된 것이 없으면 -> 컴파일러가 자동으로 추가
        public 클래스명() {}

2. 생성자 만들기
3. 생성자 오버로드


    - 함수의 시그니쳐
        패키지명.클래스명 반환값 타입 메서드명(매개변수 ...) 예외 전가
            - 시그니쳐가 동일하면 - 함수의 중목 정의 - 오류 발생
            - 시그니쳐가 동일하지 않으면 -> 다른 함수를 정의
    - 메서드 오버로드
        - 동일 함수명으로 다양한 매개변수, 반환값, 예외 전가등을 다르게 정의해서 여러개를 정의
    
정보 은닉
- 멤버 변수에 직접 값을 대입하는 것 -> 통제 불가 : 사용을 지양(멤버 변수의 접근 제어자(private))
- 멤버 변수의 값을 지정할 수 있는 접근 가능한 메서드 추가
    set
- 멤버 변수의 값을 확인할 수 있는 접근 가능한 메서드 추가
    get


    setter/getter

1. 접근제어자 정리
    public : 다른 패키지에서도 접근이 가능
    protected : 동일 패키지에서 접근 가능(default) + 외부 패키지에 있는 클래스에서 상속을 받으면 클래스 내부에서 접근 가능(private)
    default : 접근 제어자를 명시 X : 동일 패키지에서 접근 가능
    private : 클래스 내부에서만 접근 가능
    
    참고)
        다른 패키지에 있는 클래스를 사용하려면  import
        import 패키지명.클래스명

2. get(), set() 메서드

this 예약어★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
    지역변수 : 모든 인스턴스 메서드에 존재하는 지역변수
              생성된 객체의 주소값을 가지고 있는 지역변수

    메서드 : 클래스 내부에서 생성자 메서드를 호출할 때 (this(....))

static 변수(상수, 리터럴 상수, 바뀌지 않는 코드)
    static : 정적인, 고정된
    - 데이터 영역에 공간 할당, 변수가 된다.
    - 클래스 로더 -> 클래스, 코드가 구성될 때 변수가 된다.
    - 객체 생성과는 관련없는 변수
    - 객체의 참조 변수로 접근하면 인스턴스 변수와 혼동 우려 -> X
    - 정적인 방법으로 접근하는 것이 권장사항
        (클래스명으로 접근)
    - 클래스 변수

    참고)
    정적 메모리 : 생성되면 애플리케이션 종료까지 유지되는 메모리
            (데이터 영역)
    동적 메모리 : 생성 소멸을 반복하는 메모리
            (스택 영역, 힙 영역)

static 메서드
    - 객체 생성과는 상관없이 사용가능한 메서드
    - 정적인 방법으로 접근(클래스명)
    - 클래스 메서드
    - this 지역변수 X
    - 객체의 자원(인스턴스 자원)은 접근 불가(멤버 변수, 멤버 메서드)

변수의 유효범위
1. 지역변수
    - 함수가 호출되면 스택에서 생성되고, 함수가 종료되면 스택에서 제거되는 변수

2. 멤버변수(인스턴스 변수)
    - 객체가 생성되면 힙 메모리에서 생성되고 참조가 끊기면 가비지 콜렉터(GC)에 의해서 제거되는 변수

3. static 변수
    - 클래스 로더 -> 코드 구성 -> 변수공간을 데이터 영역에서 할당
    - 애플리케이션 종료시 제거

static 응용 - 싱글톤 패턴
    - 한개를 가지고 공유
    - 기능 담당하는 객체

    예)
        java.util 패키지
                .Arrays

        java.lang
                Math : 수학관련 기능 모음 클래스


      
    - ★필요한 시점★에 하나의 객체를 생성하고 공유
    
    1) 생성자를 외부에서 생성하지 못하도록 접근 제어자를 private으로 지정

    2) 객체를 클래스 내부에서 생성

    3) 내부에 생성된 객체를 접근할 수 있는 메서드를 추가


데이터 영역 메모리(코드 & 상수 영역)                                  스택 영역 메모리                                            힙 영역 메모리

        class Student                                                   main()                    new Student()--------------->(    int id(4)
            int id                                                                                      |                         String name(4)   
            String name                                                                                 |                         String subject(4)                  
            String subject                                            Student s1          <------------ |                      )             
                                                                                                        |
                                                                                                        |
        void showInfo()                                               Student s2          <------------ |                      (    int id(4)
                                                                                                                                  String name(4)
                                                                          =                                                       String subject(4)
                                                                                                                               )
                                                                      Student s3





--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
상속
1. 상속이란? 
- 하위 클래스가 상위클래스를 상속 받으면 하위클래스가 상위 클래스 자원을 접근 할 수 있는 방식


2. 클래스의 상속


3. 클래스의 상속문법
class 하위클래스 extends 상위 클래스 {

}

4. super
    - 지역변수 : 모든 인스턴스 메서드의 지역변수
                - 상위 클래스 객체의 주소값을 가지고 있는 참조 변수

    - 메서드 : super() : 모든 생성자의 첫번째 라인에 추가
                - 상위 클래스의 생성자 메서드


C() -> super() : B() -> super() : A()


C() -> B() -> A()

하위클래스가 상위클래스의 자료형으로 자동 형변환 -> 다형성

C -> B -> A
D -> A

instanceof : 객체의 생성된 출처를 확인하는 연산자

참조변수 instanceof 클래스명
-> 객체가 클래스명으로부터 생성된 객체인지 확인
-> 객체가 형변환 될 수 있는 하위클래스인지 체크


상위클래스 : 일반적인 개념
하위클래스 : 구체적인 개념

Animal
    Human
    Dog
    Bird

객체는
A -> B -> C

메서드 재정의
1. 메소드 재정의
    - 상위 클래스의 메서드의 내용을 하위 클래스가 다시 정의
    - 상위 클래스의 메서드명, 매개변수가 같으면 다시 하위 클래스에서 정의
    - 좁은 범위 -> 넓은 범위 접근 제어자로 변경 가능
    - default -> protected -> public

2. 묵시적 형변환과 메서드 재정의
3. 가상메서드

다형성
1. 다운 캐스팅과 instanceof

캡슐화, 상속, 다형성

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

추상 클래스

추상적 : 정해지지 않은 <--- ---> 구체적 : 정해진
      : 공통적인

1. 추상클래스란?
- 추상 클래스 : 메서드의 구현체가 구현되지 않은 클래스, 하위클래스가 공유하는 공통 기능, 변수
- 구체적 클래스 : 메서드의 구현체가 완전히 구현된 클래스


2. 추상클래스 문법
- 추상 클래스에서 class 앞에 abstract 예약어를 추가
- 추상메서드에 abstract 예약어를 추가
- 불완전한 클래스 -> 추상 클래스만으로 객체를 생성 X
- 상속을 통해서 하위클래스가 객체가 된다.

- 추상 메서드는 하위클래스가 따라야할 원칙, 규칙 -> 설계 원칙 / 설계의 틀



final 예약어
    - 변경 불가, 최종적

1. 변수 : 상수
2. 메서드 : 메서드 재정의 불가
3. 클래스 : 상속 불가

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

인터페이스
    - 설계 목적 용도가 정해진 클래스의 일종
    - 참고) 인터페이스 명세서

1. 인터페이스란?
    - 설계가 목적 : 추상 메서드만 정의하기 위한 목적의 클래스

2. 인터페이스 문법
    interface 인터페이스명 (
        // 추상 메서드
    )

3. 클래스에서 인터페이스 구현하기
    class 하위클래스명 implements 인터페이스명 {

    }
4. 인터페이스 구현과 형변환(다향성)
콜렉션 프레임워크(Collection Framework)
List
Set
Map

5. 인터페이스의 요소 살펴보기
    1) 인터페이스 상수
    2) 디폴트 메서드
    
    3) 정적 메서드
    4) private 메서드

인터페이스 활용하기
1. 한 클래스가 여러 인터페이스를 구현하는 경우
- 여러 인터페이스를 하나의 클래스에서 구현 가능


주문 - 판매자, 구매자

참고)
클래스에서 상속은 하나의 클래스만 상속 가능
  - 다중 상속시 동일한 메서드가 정의되면 어느쪽을 실행할지 알 수 없다.

2. 두 인터페이스의 디폴트 메서드가 중복되는 경우
	- 실행의 애매함 -> 오류
	- 실행 출처를 하위클래스가 결정
	- 하위클래스가 재 정의하거나
	
3. 인터페이스 상속하기
	- extends
	- 클래스의 상속과는 다르다, 여러개를 상속 받을 수 있다.

C -> B -> A

C() -> super() : B() -> super() : A()

C() -> B() -> A()

변수 instanceof 클래스

일반적인 개념
Amimal

구체적인 개념
Human
Dog
Bird

메서드 재정의
	- 상위클래스와 동일한 반환값, 메서드명, 매개변수를 하위 클래서 정의
	
	
추상클래스
- 메서드의 정의부분만 O, 구현코드 X -> 추상 메서드 -> 추상 클래스
- abstract

- 공통 기능, 공통 변수

인터페이스
	- 설계로 용도가 제한된 클래스의 일종
    - 설계는 추상메서드로 틀을 정의
	
	API(Application Programing Interface)

    interface 인터페이스명 {

    }

    implements



    주문 - 구매자, 판매자

인터페이스간 상속
    - 다중 상속 가능

내부 클래스
- 클래스 내부에 정의된 클래스

1. 인스턴스 내부 클래스
    - 인스턴스 자원과 비슷한 성격
    - 인스턴스 변수(멤버변수), 인스턴스 메서드와 유사한 성격
    - 외부 클래스의 객체가 생성되어야 생성할 수 있는 클래스

2. 정적 내부 클래스
    - 정적 자원과 비슷한 성격
    - 정적 변수, 정적 메서드와 비슷
    - 일반 클래스와 큰 차이없이 사용 가능
    - 외부클래스의 인스턴스 사용 불가

3. 지역 내부 클래스 ★☆★☆★☆★☆★☆★☆★☆★☆
    - 메서드 안에 정의된 클래스, 메서드 안에 객체가 생성

    - 추상클래스와 인터페이스가 객체가 될 수 있다.
        - 상황 조건 : 지역 내부, 멤버 변수
        - 객체 생성시 미구현된 메서드를 구현 함으로써 객체가 될 수 있다.

------------------------------------------------------------------------------------



예외처리
1. 오류와 예외
    오류(Error) : 시스템의 오류, JVM 오류 ... : 통제 불가 오류

    예외(Exception) : 코드 상의 오류 : 통제 가능한 오류
                        - 버그

2. 예외 클래스의 종류

        Throwable

    Error       Exception


Exception
    - Exception을 바로 상속받은 예외 클래스
        예) java.io.IOException / 파일을 읽을때, 쓸때 (FileInputStream, FileOutputStream)

            java.io.FileNotFoundException

            - 예외가 있든 없든 처리가 안되어 있으면 컴파일 X
            - 예외의 체크는 컴파일시 체크, 예외가 있으면 컴파일 X
            - 예외가 발생하든 안하든 반드시 적절한 예외 처리가 필요한 예외
            - 엄격한 예외, 형식을 매우 중시

    -RuntionException을 중간에 상속 받은 예외 클래스
        -Runtime : 실행
        예) java.lang.ArithmeticException : 0으로 나눌때 발생

        - 예외가 발생하더라도 컴파일 O, class 파일 생성
        - 예외의 체크는 실행 중 체크, 실행이 되려면? class 파일 필요 (컴파일은 된다...)
        - 유연한 예외, 형식은 X
        

    예외가 발생하면 프로그램 중단! -> 프로그램 중단을 막기 위한 조치
        - 예외처리의 목적 : 예외가 발생시 적절한 조치 -> 서비스 중단을 막는 것


참고)
    java.exe : 클래스파일 실행
    java.exe : java -> class 컴파일


예외처리하기
1. try ~ catch문

    try {
        //예외가 발생할 가능성이 있는 코드

    } catch (예외 객체 ...) {
        // 예외 발생시 처리할 코드
    }
    
참고)
    예외 발생
        throw 예외객체;

    예외, 오류 -> 원인을 확인을 하는것이 중요

    예외 클래스 주요 메서드 : 정보확인
            java.lang.Throwable
                                    : String getMessage() - 오류 메시지 확인
                                    : void printStackTrace() : 

     

2. try-catch-finally문
    - 자원을 소비하는 객체 - FileInputStream, FileOutputStream, Connection, PrepareStatement...
    - 자원 해제 -> 애플리케이션 종료시에 해제
    - 서버? 종료 X -> 자원해제를 하지 않으면 메모리 부족 현상 발생
    - 자원 해제를 적절하게 해야 한다(Close...)

    try {

    }catch (...) {
        ...
    } finally {
        // 예외가 발생하든 안하든 항상 실행되는 코드
        // return 하더라도 코드가 실행
    }
3. try-with-resources문
    - JDK7에서 추가
    - 자원 해제를 자동

    try ( 해제할 자원 객체;
           해제할 자원 객체 ...) {
          // 예외가 발생할 가능성이 있는 코드
    } catch(예외 객체 ..) {

    }


    자원 자동 해제의 기준
        AutoCloseable 인터페이스의 구현 클래스
            - close() 메서드 자동 호출

    참고)
        instance

예외 처리 미루기
1. 예외 처리를 미루는 throws 사용하기
    - 메서드를 호출하는쪽에서 예외 처리 전가
    - 전가시키는 예외에 대해서 명시(throw)
        메서드 매개변수 뒤쪽에 throw 전가할 예외 ...
    - Exception을 상속 받은 경우(RuntimeException이 없는 경우)

2. 다중 예외 처리
    ArithmeticException
    NullPointerException 
    
    try {

    } catch (ArithmeticException e) {
        ....
    } catch (NullPointerException e) {
        ....
    }


    try {

    } catch (ArithmeticException | NullPointerException e) {

    } // 처리가 동일할 경우 이런식으로 묶어서 사용가능

3. 사용자 정의 예외
    - JDK 기본 정의 예외 외에 따로 작성하는 예외
    - 로그인 기능
        - 아이디, 비번
        - 아이디가 일치 X -> 예외 발생
        - 비밀번호가 일치 X -> 예외 발생

    예외 클래스 작성 - Exception, RuntionException 클래스를 상속받고 생성자만 정의

java.lang 패키지
- 기본적으로 많이 사용하는 클래스들이 포함

예) String
    java.lang.String

컴파일러가 패키지명 바로 아래쪽 import java.lang.*; 추가
- lang 패키지의 모든 클래스는 그냥 사용 가능

OBject 클래스
    - 모든 클래스의 상위 클래스
    - 상속이 명시 X -> extends java.lang.Object

- OBject 클래스에 정의된 메서드
1. toString() 메서드
    - 객체의 참조 변수를 출력할때 자동 호출

    public String toString() {
        retrun getClass().getName() + "@" + integer.toHexString(hashCode());
    }

    getClass().getName() : 패키지명을 포함한 클래스명

    - 재정의를 통해서 멤버 변수의 값을 확인하는 용도로 많이 사용

    참고)
        Object
            Class getClass()

            Class 객체 : 클래스 로더에 의해서 생성 : 클래스 정보가 담겨 있는 객체
            - 모든 클래스의 정적 변수로 class가 존재
            - OBject::getClass() : 인스턴스 메서드 : 객체 생성후 Class 객체 조회
                - 클래스 내부에서 클래스 정보를 조회

2. equals() 메서드
    public boolean equals(Object obj) {
        return (this == obj);
    }

    - 동일성 비교 : 동일한 주소 ( == ) : 물리적 동일성 / 주소값의 비교

    - 동등성 비교 : 동등한 가치를 가지고 있는지
                   equals(...) : 재정의를 통해서 동등성 비교

3. hashCode() 메서드
    - 객체의 주소값

    - 검색을 위한 유일한 값
    - OBject에 정의된 기본 값 : 객체의 주소(유일한 값의 측면에서....)

    - 일반적으로 동등성 비교는 equals and hashCode


참고)
    컬렉션 프레임워크
        Set : 중복 X

    

    java.util 패키지 : 편의 기능이 모여져 있는 패키지
        - Objects : 객체의 편의 기능
        - Arrays : 배열의 편의 기능
        - Collections : 컬렉션의 편의 기능

    static OBject.hash(OBject...values)
        ... : 가변 매개변수

    

String 클래스

1. String을 선언한는 두 가지 방법
    String 변수명 = "문자열"; - 문자열 상수 : 하나의 객체만 생성
    String 변수명 = new String("문자열"); - 생성할때 마다 다른 객체가 생성

    문자열의 객체의 형태가 다양하므로 equals(...) : 동등성 비교를 한다.


2. String 클래스의 final char[] 변수(JDK11)
    문자열 : 문자(char)가 여러개 줄지어 있는 형태

    private final byte[] values : 상수
        -> 문자열로 한번 생성되면 변경 불가
        -> 문자열 갯수 만큼 배열이 생성, 변경 X
        -> 문자열을 결합할때마다 공간의 크기가 변경 -> 새로 만들어서 변경
        -> 문자열 결합을 많이 할 수록 성능 저하 문제가 발생


    참고)
    JDK12
        final byte[]...

3. StringBuffer와 StringBuilder 클래스 활용하기
    
    byte[] values : 버퍼(기본값 16바이트)


    참고)
        버퍼(buffer) : 임시 메모리 공간


Wrapper 클래스
- 기본 자료형을 위한 클래스
    - 기본자료형의 기능 부여하기 위한 클래스


정수형          클래스
    byte        Byte
    short       Short
    int         Integer
    long        Long

실수형
    float       Float
    double      Double

논리형
    boolean     Boolean

문자형
    char        Character



class Integer {

    ....

    private int value;

    ...
}

2. Integer 클래스 사용하기
1) Integer 클래스의 메서드

3. 오토박싱과 언박싱

    - 오토박싱
        - 기본형 -> Wrapper 클래스의 객체
        int num1 = 10;
        Integer num2 = num1; // Integer num2 = Integer.valueOf(num1);

    - 언박싱
        - Wrapper 클래스의 객체 -> 기본형
        int num3 = num1 + num2 // int num3 = num1 + num2.intValue();



    참고)
        new Integer(...) : Deprecated / 권장사항 Integer.valueOf(...)


    변환기능

        int intValue();
        long longValue();
        double doubleValue();
        ...

        Integer
            static int parseInt(String s); : 문자열 -> 정수(int)

        Double
            static double parseDouble(String s); : 문자열 -> 실수(double)



        java.lang.Number : 추상 클래스
            - Byte, Short, Integer, Double, Float ...



Class 클래스
    - 클래스의 정보가 담겨 있는 객체
    - 자동 생성되는 객체
    - 모든 클래스의 정적 변수 class
    - OBject::getClass()

1. Class 클래스를 선언하고 클래스 정보를 가져오는 방법

2. Class 클래스를 활용해 클래스 정보 알아보기
3. Class.forName()을 사용해 동적 로딩하기
    실행중 클래스 파일을 -> 데이터 영역, 반환값 Class

유용한 클래스
1. java.lang.Math 클래스
    - 수학관련 유용한 함수 모음..
    - ... abs() : 절대값(음수 -> 양수)
    - round() : 반올림
    - ceil() : 올림
    - floor() : 버림
    - sign() : 부호(1 -> 양수, -1 -> 음수, 0)
    - pow(a,b) : a의 b승
    - sqrt()
    - random() : 0~1 사이의 double 범위 난수

2. java.util.Object 클래스
    - 객체의 편의 기능 모음
    참고)
        java.util.Arrays : 배열의 편의 기능 모음..
        java.util.Collections : 컬렉션의 편의 기능 모음..
        java.util.stream.Collection : 데이터 수집용 편의 메서드 모음..

3. java.util.Random 클래스

4. java.util.Scanner 클래스
    - 콘솔에서 입력, 파일 데이터를 간단하게 입력

5. java.util.StringTokenizer 클래스
    - 토큰 (구분 문자) : 문자 분리


6. 정규표현식
    java.util.regex 패키지
        - 특정패턴 -> 검증, 문자열 추출

String 클래스 메서드


String 
    static String format(String format, Object ... args)

        형식화 패턴
        %s : 문자열
        %c : 문자
        %d : 정수
        %f : 실수 (%.2f - 소수점 2자리)

    substring(시작위치) : 시작위치부터 끝까지
    substring(시작위치, 종료위치) : 시작위치 <= s < 종료위치

    참고)
        System.out : PrintStream

                        Print() : 출력 (줄개행 X)
                        Println() : 출력 + 줄개행(\n)
                        Printf() : 형식화 + 출력
                                  - 줄 개행 : \n, %n
    
        


열거형(enums)
1. 열거형이란? (JDK5)
    - 상수만을 위해 용도가 정해진 클래스의 일종

2. 열거형 정의와 사용

enum 클래스명 {
    상수,
    ..
}

==

switch ~ case

3. 모든 열거형 상위 클래스 - java.lang.Enum
    1. extends java.lang.Enum
    2. 상수 -> 정적 상수 객체
    3. 모든 생성자 : private 접근 제어자
        - 외부에서 객체를 생성 할 수 있으면 상수로써 의미 X
    4. 추상 클래스

1) Enum 클레스에 정의된 메서드
    String name(), String toString() : Enum 상수 이름 문자열
    int ordinal() : Enum 상수의 위치 번호(0부터 시작)

    static T valueOf() : 문자열 -> Enum 상수로 변환

2) 컴파일러가 자동으로 추가해주는 메서드
    values() : Enum 클래스의 상수 목록을 배열로 반환
    .valueOf(String name) : 문자열 -> 현재 Enum 클래스의 상수 변환

4. 열거형에 멤버 추가하기
5. 열거형에 추상메서드 추가하기













컴파일러가 자동 추가해주는 부분

1. 기본 생성자
2. 모든 생성자 첫번째 줄 super();
3. 객체의 참조 변수 출력 -> 변수.toString();
4. 인터페이스 메서드 앞에 public abstract
5. 인터페이스 변수 앞에 public static final
6. 지역 내부 클래스, 지역변수의 상수화 : final
7. import java.lang.*;
8. extends java.lang.Object






